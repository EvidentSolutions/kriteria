package fi.evident.kriteria.ksp

import com.google.devtools.ksp.getClassDeclarationByName
import com.google.devtools.ksp.isPublic
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.addOriginatingKSFile
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo
import fi.evident.kriteria.annotations.DelicateCriteriaApi
import fi.evident.kriteria.expression.*
import jakarta.persistence.*

/**
 * Find entities and creates typed Path-accessors for them.
 */
private class CriteriaMetaProcessor(
    private val codeGenerator: CodeGenerator,
    private val packageName: String,
    private val logger: KSPLogger,
) : SymbolProcessor {

    private val optInType = ClassName("kotlin", "OptIn")
    private val delicateApiType = DelicateCriteriaApi::class.asClassName()

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val entityClasses = resolver.getClassesWithAnnotation<Entity>()
        val mappedSuperclassClasses = resolver.getClassesWithAnnotation<MappedSuperclass>()
        val embeddableClasses = resolver.getClassesWithAnnotation<Embeddable>()
        val allClasses = entityClasses + mappedSuperclassClasses + embeddableClasses

        context(resolver) {
            for (classDeclaration in allClasses)
                generateCriteriaMeta(classDeclaration).writeTo(codeGenerator, aggregating = false)
        }

        return emptyList()
    }

    context(resolver: Resolver)
    private fun generateCriteriaMeta(classDeclaration: KSClassDeclaration): FileSpec {
        val file = FileSpec.builder(packageName, classDeclaration.simpleName.asString() + "CriteriaMeta")
        file.addAnnotation(
            AnnotationSpec.builder(Suppress::class)
                .addMember("%S, %S, %S", "unused", "RedundantVisibilityModifier", "REDUNDANT_VISIBILITY_MODIFIER")
                .build()
        )
        file.addAnnotation(AnnotationSpec.builder(optInType).addMember("%T::class", delicateApiType).build())
        file.addFileComment("Generated by ${javaClass.simpleName} - do not modify")

        logger.info("Processing entity: ${classDeclaration.simpleName.asString()}")

        for (property in classDeclaration.getAllProperties()) {
            if (!property.validate()) continue
            if (!property.isPersistentProperty) continue

            val kind = when {
                property.hasAnnotation<ManyToMany>() -> PropertyKind.MANY_TO_MANY
                property.hasAnnotation<ManyToOne>() -> PropertyKind.MANY_TO_ONE
                property.hasAnnotation<OneToMany>() -> PropertyKind.ONE_TO_MANY
                else -> PropertyKind.BASIC
            }

            processProperty(classDeclaration, property, file, kind)

            // Process many-to-one properties both normally and as basic properties
            if (kind == PropertyKind.MANY_TO_ONE)
                processProperty(classDeclaration, property, file, PropertyKind.BASIC)
        }

        return file.build()
    }

    context(resolver: Resolver)
    private fun processProperty(
        classDeclaration: KSClassDeclaration,
        property: KSPropertyDeclaration,
        file: FileSpec.Builder,
        kind: PropertyKind,
    ) {
        val propertyName = property.simpleName.asString()
        val entityNameSimple = classDeclaration.simpleName.asString()

        val visibility = if (classDeclaration.isPublic()) KModifier.PUBLIC else KModifier.INTERNAL

        val propertyType = kind.createPropertyType(property.type.resolve())
        val receiverType = kind.createReceiverType(classDeclaration)

        val property = PropertySpec.builder(
            name = propertyName,
            type = propertyType,
        )
            .addModifiers(visibility)
            .addKdoc("Path accessor for [%L.%L].", entityNameSimple, propertyName)
            .receiver(receiverType)
            .getter(
                FunSpec.getterBuilder()
                    .addAnnotation(
                        AnnotationSpec.builder(JvmName::class)
                            .addMember("name = %S", "get${entityNameSimple}_${propertyName}").build()
                    )
                    .addStatement("return ${kind.resolverFunction}(%S)", propertyName).build()
            )

        val containingFile = classDeclaration.containingFile
        if (containingFile != null)
            property.addOriginatingKSFile(containingFile)

        file.addProperty(property.build())
    }
}

private enum class PropertyKind(val resolverFunction: String) {
    BASIC("getBasicUnsafe"),
    MANY_TO_ONE("getManyToOneUnsafe"),
    ONE_TO_MANY("getCollectionReferenceUnsafe"),
    MANY_TO_MANY("getMapReferenceUnsafe");

    context(resolver: Resolver)
    fun createPropertyType(type: KSType): TypeName = when (this) {
        BASIC -> basicChildType.parameterizedBy(type.makeNotNullable().toTypeName())
        MANY_TO_ONE -> manyToOneChildType.parameterizedBy(type.makeNotNullable().toTypeName())
        ONE_TO_MANY -> {
            val elementType = resolveCollectionElementType(type.makeNotNullable())
            collectionReferenceType.parameterizedBy(elementType)
        }
        MANY_TO_MANY -> {
            val (key, value) = resolveMapParameters(type.makeNotNullable())
            mapReferenceType.parameterizedBy(key, value)
        }
    }

    fun createReceiverType(entityClass: KSClassDeclaration): TypeName {
        val typeName = WildcardTypeName.producerOf(entityClass.asType(emptyList()).toTypeName())
        return when (this) {
            BASIC -> pathType.parameterizedBy(typeName)
            MANY_TO_ONE, ONE_TO_MANY, MANY_TO_MANY -> fromType.parameterizedBy(STAR, typeName)
        }
    }

    context(resolver: Resolver)
    private fun resolveCollectionElementType(type: KSType): TypeName {
        val collectionType = resolver.getClassDeclarationByName<Collection<*>>()!!

        if (collectionType.asStarProjectedType().isAssignableFrom(type))
            return type.arguments.first().type!!.resolve().toTypeName()

        throw IllegalArgumentException("expected collection type, got: $type")
    }

    context(resolver: Resolver)
    private fun resolveMapParameters(type: KSType): Pair<TypeName, TypeName> {
        val mapType = resolver.getClassDeclarationByName<Map<*, *>>()!!

        if (mapType.asStarProjectedType().isAssignableFrom(type)) {
            check(type.arguments.size == 2) { "expected map type with 2 arguments, got: $type" }

            val (key, value) = type.arguments.map { it.type!!.resolve().toTypeName() }
            return key to value
        }

        throw IllegalArgumentException("expected collection type, got: $type")
    }

    companion object {
        private val pathType = KrPath::class.asClassName()
        private val fromType = KrFrom::class.asClassName()
        private val basicChildType = KrPropertyRef::class.asClassName()
        private val manyToOneChildType = KrManyToOneRef::class.asClassName()
        private val collectionReferenceType = KrCollectionRef::class.asClassName()
        private val mapReferenceType = KrMapRef::class.asClassName()
    }
}

class CriteriaMetaProcessorProvider : SymbolProcessorProvider {

    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        CriteriaMetaProcessor(
            codeGenerator = environment.codeGenerator,
            packageName = ProcessorConfiguration(environment.options).targetPackage,
            logger = environment.logger
        )
}
