package fi.evident.kriteria.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.*
import fi.evident.kriteria.annotations.CriteriaConstructor
import fi.evident.kriteria.annotations.DelicateCriteriaApi
import fi.evident.kriteria.expression.KrExpressionContext
import fi.evident.kriteria.expression.KrSelection

/**
 * Finds `@CriteriaConstructor` annotated constructors and generates a `constructXyz` function for them.
 */
private class CriteriaConstructorProcessor(
    private val codeGenerator: CodeGenerator,
    private val packageName: String,
    private val logger: KSPLogger,
) : SymbolProcessor {

    private val selectionType = KrSelection::class.asClassName()
    private val expressionContextType = KrExpressionContext::class.asClassName()
    private val optInType = ClassName("kotlin", "OptIn")
    private val delicateApiType = DelicateCriteriaApi::class.asClassName()

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val criteriaConstructors = resolver.getFunctionsWithAnnotation<CriteriaConstructor>()

        for (constructor in criteriaConstructors)
            processClassWithCriteriaConstructor(constructor)?.writeTo(codeGenerator, aggregating = false)

        return emptyList()
    }

    @OptIn(ExperimentalKotlinPoetApi::class)
    private fun processClassWithCriteriaConstructor(constructor: KSFunctionDeclaration): FileSpec? {
        val classDeclaration = constructor.parentDeclaration as? KSClassDeclaration ?: return null
        val className = classDeclaration.simpleName.asString()

        val file = FileSpec.builder(packageName, className + "CriteriaConstructor")
        file.addAnnotation(AnnotationSpec.builder(Suppress::class).addMember("%S, %S, %S, %S, %S", "unused", "RedundantVisibilityModifier", "REDUNDANT_VISIBILITY_MODIFIER", "UNCHECKED_CAST", "USELESS_CAST").build())
        file.addAnnotation(AnnotationSpec.builder(optInType).addMember("%T::class", delicateApiType).build())
        file.addFileComment("Generated by ${javaClass.simpleName} - do not modify")
        file.addImport("fi.evident.kriteria.expression", "constructUnsafe")

        logger.info("Processing class with @CriteriaConstructor: ${classDeclaration.simpleName.asString()}")

        val functionName = "construct$className"
        val typeParameters = classDeclaration.typeParameters
        val typeParameterResolver = typeParameters.toTypeParameterResolver()

        // Get the return type with type parameters
        val constructedObjectType = if (typeParameters.isEmpty())
            classDeclaration.asType(emptyList()).toTypeName(typeParameterResolver)
        else
            classDeclaration.toClassName().parameterizedBy(typeParameters.map { TypeVariableName(it.name.asString()) })

        val returnType = selectionType.parameterizedBy(constructedObjectType)

        // Create a function that takes Selection<*> parameters and returns CompoundSelection<T>
        val function = FunSpec.builder(functionName)
            .returns(returnType)
            .addModifiers(KModifier.INTERNAL) // TODO: use the visibility of the original class

        val containingFile = classDeclaration.containingFile
        if (containingFile != null)
            function.addOriginatingKSFile(containingFile)

        for (typeParam in typeParameters)
            function.addTypeVariable(TypeVariableName(
                name = typeParam.name.asString(),
                bounds = typeParam.bounds.map { it.resolve().toTypeName(typeParameterResolver) }.toList()
            ))

        for (parameter in constructor.parameters)
            function.addParameter(
                name = parameter.name?.asString() ?: continue,
                type = selectionType.parameterizedBy(parameter.type.toTypeName(typeParameterResolver))
            )

        function.contextParameter("ctx", expressionContextType)

        val parameterNames = constructor.parameters.mapNotNull { it.name?.asString() }.joinToString(", ")
        function.addStatement("return constructUnsafe(%T::class, $parameterNames) as %T", classDeclaration.toClassName(), returnType)

        file.addFunction(function.build())
        return file.build()
    }
}

class CriteriaConstructorProcessorProvider : SymbolProcessorProvider {

    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        CriteriaConstructorProcessor(
            codeGenerator = environment.codeGenerator,
            packageName = ProcessorConfiguration(environment.options).targetPackage,
            logger = environment.logger
        )
}
